# from tvm.script import ir as I
# from tvm.script import tir as T

@I.ir_module
class Module:
    @T.prim_func
    def gemm(A_handle: T.handle, B_handle: T.handle, C_handle: T.handle):
        T.func_attr({"target": T.target({"host": {"keys": ["cpu"], "kind": "llvm", "mtriple": "x86_64-pc-linux-gnu", "tag": ""}, "keys": ["tenstorrent"], "kind": "tenstorrent", "tag": ""}), "tt_layout_type": "dram_interleaved", "tt_schedule_order": "row_major", "tt_schedule_policy": "contiguous", "tt_tile_height": 32, "tt_tile_width": 32})
        A = T.match_buffer(A_handle, (256, 256), "float16", strides=(256, 1))
        B = T.match_buffer(B_handle, (256, 256), "float16", strides=(256, 1))
        C = T.match_buffer(C_handle, (256, 256), "float16", strides=(256, 1))
        # with T.block("root"):
        bx = T.launch_thread("blockIdx.x", 8)
        by = T.launch_thread("blockIdx.y", 8)
        tx = T.launch_thread("threadIdx.x", 128)
        ty = T.launch_thread("threadIdx.y", 1)
        tz = T.launch_thread("threadIdx.z", 1)
        with T.block("tilelang_root"):
            T.reads(A[by * 32, 0:225], B[0:225, bx * 32], C[by * 32, bx * 32])
            T.writes()
            A_shared = T.alloc_buffer((32, 32), "float16", scope="shared.dyn")
            B_shared = T.alloc_buffer((32, 32), "float16", scope="shared.dyn")
            C_local = T.alloc_buffer((32, 32), scope="local.fragment")
            T.fill(T.tvm_access_ptr(T.type_annotation("float32"), C_local.data, 0, 1024, 2), 0)
            for k in T.serial(8, annotations={"num_stages": 3}):
                T.copy(T.region(A[by * 32, k * 32], 1, 32, 32), T.region(A_shared[0, 0], 2, 32, 32), -1, T.bool(False), 0)
                T.copy(T.region(B[k * 32, bx * 32], 1, 32, 32), T.region(B_shared[0, 0], 2, 32, 32), -1, T.bool(False), 0)
                T.gemm(T.tvm_access_ptr(T.type_annotation("float16"), A_shared.data, 0, 1024, 1), T.tvm_access_ptr(T.type_annotation("float16"), B_shared.data, 0, 1024, 1), T.tvm_access_ptr(T.type_annotation("float32"), C_local.data, 0, 1024, 3), T.bool(False), T.bool(False), 32, 32, 32, 0, T.bool(False), 32, 32, 0, 0, 1, 0, T.uint32(0), 0, 0)
            T.copy(T.region(C_local[0, 0], 1, 32, 32), T.region(C[by * 32, bx * 32], 2, 32, 32), -1, T.bool(False), 0)